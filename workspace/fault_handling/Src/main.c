/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/* System Handler Control and State Register (SHCRS); one of the System Control Block registers */
#define	SHCSR			(*(uint32_t volatile *)0xE000ED24)
#define USGFAULTENA		(1 << 18)
#define BUSFAULTENA		(1 << 17)
#define MEMFAULTENA		(1 << 16)
/* UsageFault Status Register (UFSR) - 16-bit register */
#define UFSR			(*(uint32_t volatile *)0xE000ED2A)


/*
 * Instructions
 *
 * 1. Enable all configurable exceptions (i.e., UsageFault, MemManage, BusFault)
 * 2. Implement fault handlers
 * 3. Force the processor to execute some undefined instruction
 * 4. Analyze the faults (using Fault Status and Fault Address Registers)
 */

int main(void)
{
	/* Enable all configurable exceptions (i.e., UsageFault, MemManage, BusFault) */
	SHCSR |= USGFAULTENA;	/* Enable UsageFault */
	SHCSR |= BUSFAULTENA;	/* Enable BusFault */
	SHCSR |= MEMFAULTENA;	/* Enable MemManage */

	/* Force the processor to execute some undefined instruction */
	uint32_t volatile *pSRAM = (uint32_t volatile *)0x20010000;	/* Random address within SRAM */
	*pSRAM = 0xFFFFFFFF;	/* Undefined op-code */

	void (*some_addr)(void);		/* Defining a function pointer */
	some_addr = (void *)0x20010001; /* Setting 'some_addr' to 0x20010001 but not 0x20010000
									   has to do with Thumb ISA. Make sure to understand what's
									   happening behind the scenes.
									   Hint: Any branch instruction that writes to PC (Program Counter)
									   only updates  bits 31:1 and forces '0' into the 0th bit.
									   This is how the system works  well.
									   You can check this by setting the bit[0] to 0 and
									   monitor the value of the UFSR! */
	some_addr();					/* Force jump to 0xFFFFFFFF (undefined instruction) */

	/* Analyze the faults */

    /* Loop forever */
	for(;;);
}

/* HardFault handler */
void HardFault_Handler(void)
{
	printf("Exception: HardFault\n");
	while (1);
}

/* MemManage handler */
void MemManage_Handler(void)
{
	printf("Exception: HardFault\n");
	while (1);
}

/* BusFault handler */
void BusFault_Handler(void)
{

	printf("Exception: BusFault\n");
	while (1);
}

/* UsageFault handler */
void UsageFault_Handler(void)
{
	printf("Exception: UsageFault\n");
	printf("UFSR = %lx\n", UFSR & 0xFFFF);	/* Read only 16 bits */
	while (1);
}
